---
title: '反射'
date: 2021-11-27 18:00:15
# 永久链接
permalink: '/java/reflectlearn'
sidebar: 'auto'
isShowComment: true
categories:
 - java
tags:
 - null
---



## 反射

>反射机制是在<kbd>运行状态</kbd>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能成为`java`的反射机制。
>
>在编译后产生的字节码文件时，类加载器子系统通过二进制字节流，负责从文件系统加载`class`文件。在执行`java.exe`程序的时候，将字节码文件读入JVM中 --> <kbd>这个过程叫类的加载</kbd>。
>
>然后在内存中对应创建一个`java.lang.Class`对象 -> 这个对象会被放入字节码信息中，这个`Class`对象，就对应加载那个字节码信息，这个对象被作为程序访问方法区中的这个类的各种数据的外部接口。
>
>所以，通过这个对象看到的类的结构，我们形象的称反射这种“看透”类的能力，被称之为"introspection"(内省、内观、反省)。



:::tip

说明：在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。如果没有被加载，JVM会根据类的名称找到`.class`文件并加载它。一旦某个类型的`Class`对象已被加载到内存，可以用它来产生该类型的所有对象。

:::



<!-- more -->



**案例**: <kbd>美团外卖</kbd> -> <kbd>付款</kbd> -> <kbd>选择支付</kbd> -> <kbd>要么微信支付，要么支付宝支付</kbd>



**美团支付接口**

```java
// 接口的制定方：美团外卖
public interface Mtwm {
    // 在线支付
    void payOnline();
}
```

**别的支付实现方法**

```java
public class WeChat implements Mtwm {
    @Override
    public void payOnline() {
        System.out.println("我已经点了外卖，使用了微信支付");
    }
}


public class AliPay implements Mtwm {
    @Override
    public void payOnline() {
        System.out.println("我也点了外卖，使用了支付宝支付");
    }
}

public class BankCard implements Mtwm {
    @Override
    public void payOnline() {
        System.out.println("我也点了外卖，使用了招商银行卡支付");
    }
}
```

**测试类**

```java
public class Test {
    public static void main(String[] args) {

        // 定义一个字符串，用来模拟前台的支付方式
        String str = "微信";
        if ("微信".equals(str)) {
            pay(new WeChat());
        }
        if ("支付宝".equals(str)) {
            pay(new AliPay());
        }

        if ("招商银行".equals(str)) {
            pay(new BankCard());
        }
    }

    public static void pay(WeChat wc) {
        wc.payOnline();
    }

    public static void pay(AliPay aliPay) {
        aliPay.payOnline();
    }

    public static void pay(BankCard bankCard) {
        bankCard.payOnline();
    }
}
```

**使用多态优化**

```java
public class Test {
    public static void main(String[] args) {

        // 定义一个字符串，用来模拟前台的支付方式
        String str = "微信";
        if ("微信".equals(str)) {
            pay(new WeChat());
        }
        if ("支付宝".equals(str)) {
            pay(new AliPay());
        }

        if ("招商银行".equals(str)) {
            pay(new BankCard());
        }
    }

    // 方法的形参是接口，具体传入的是接口实现类的对象
    public static void pay(Mtwm mt) {
        mt.payOnline();
    }
}
```

:::tip

多态确实可以提高代码的扩展性，但是扩展性没有提高到最好，上面这一块，如果支付方式越来越多，或者某一个不继续使用了，添加分支和删除分支，都是一个不好的操作。

:::



**解决办法：反射机制**

```java
public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        // 这个是我的包的地址下的WeChat类
        String str = "com.wx.virus.test01.WeChat";

        // 利用反射
        Class<?> clzz = Class.forName(str);
        Object o = clzz.newInstance();
        Method method = clzz.getMethod("payOnline");
        method.invoke(o);
    }
}

```



## Class类

>   将具体的实例向上抽取形成一个”类“的，这个类就是`java.lang.Class`，可以通过`Class`类的字节码信息可以获取对象内容，以获取方法吗和属性等。

想要获取属性：<kbd>Class类</kbd>-><kbd>得到具体的实例(对象)</kbd>-><kbd>通过对象得到属性、方法、构造器</kbd>



## 获取字节码信息的四种方式

先定义几个类

```java
public class Person {
    private int age;
    public String name;

    private void eat() {
        System.out.println("person eat");
    }

    public void sleep() {
        System.out.println("person sleep");
    }
}


public class Student extends Person {
    private int sno;
    double height;
    protected double weight;
    public double score;

    public String showInfo() {
        return "我是一名三号学生";
    }

    private void work() {
        System.out.println("我是程序员");
    }

    public Student() {
    }

    public Student(int sno) {
        this.sno = sno;
    }

    Student(int sno, double weight) {
        this.sno = sno;
        this.weight = weight;
    }
}

```



### 通过`getClass`方法获取

```java
public class Test {
    public static void main(String[] args) {
        // 获取Person的字节码信息

        // 方式1 通过getClass 方法获取
        Person p = new Person();
        Class<? extends Person> pClass = p.getClass();
        System.out.println(pClass);
    }
}

// 输出
class com.wx.virus.test02.Person
```



### 通过内置class属性

```java
public class Test {
    public static void main(String[] args) {
        // 获取Person的字节码信息
        // 方式2 通过内置的 class 属性
        Class c2 = Person.class;
        System.out.println(c2);
    }
}
```

:::tip

```java
System.out.println(pClass == c2); // true
```

方式1和方式2不常用

:::



### 通过Class.forName("字符串")方法获取(用的最多)

```java
public class Test {
    public static void main(String[] args) throws ClassNotFoundException {
        // 方式3
        Class<?> c3 = Class.forName("class com.wx.virus.test02.Person");
    }
}
```

### 利用类的加载器(了解技能点)

```java
public class Test {
    public static void main(String[] args) throws ClassNotFoundException {
        // 方式4 通过类加载器
        ClassLoader classLoader = Test.class.getClassLoader();
        Class<?> c4 = classLoader.loadClass("class com.wx.virus.test02.Person");
    }
}
```



## Class类的具体的实例

1.   类：外部类、内部类
2.   接口
3.   注解
4.   数组
5.   基本数据类型
6.   void



```java
public class Test {
    public static void main(String[] args) {

        Class<Comparable> c5 = Comparable.class;
        Class c6 = Override.class;

        int[] arr1 = {1, 2, 3};
        Class c7 = arr1.getClass();

        int[] arr2 = {5, 6, 7};
        Class c8 = arr2.getClass();
        System.out.println(c7 == c8); // true

        Class c9 = int.class;
    }
}

```

