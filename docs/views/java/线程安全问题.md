---
title: '线程安全问题'
date: 2022-02-13 16:50:15
# 永久链接
permalink: '/java/threadsafe'
sidebar: 'auto'
isShowComment: true
categories:
 - java
tags:
 - null
---



## 简单抢票代码分析

```java
public class BuyTicketThread implements Runnable {

    int ticketNum = 10;

    /**
     * @see Thread#run()
     */
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (ticketNum > 0) {
                System.out.println("我在" + Thread.currentThread().getName() + "买到了第" + ticketNum-- + "张车票");
            }
        }
    }
}

```

```java
public class Main {
    public static void main(String[] args) {
        // 定义一个线程对象
        BuyTicketThread t = new BuyTicketThread();
        // 窗口1买票
        Thread t1 = new Thread(t, "窗口1");
        t1.start();

        // 窗口2买票
        Thread t2 = new Thread(t, "窗口2");
        t2.start();

        // 窗口3买票
        Thread t3 = new Thread(t, "窗口3");
        t3.start();
    }
}

```

当前排队抢票代码看起来挺正常的。但是可能会发现如下问题：

-   可能会出现两个第10张票，或者出现三个第10张票
-   可能会出现第0张票、第-1张票和第-2张票



:::warning 执行抢票的有2个流程

```java
System.out.println("我在" + Thread.currentThread().getName() + "买到了第" + ticketNum-- + "张车票");
```

1.   获取到`ticketNum`这个值
2.   进行`ticketNum--`操作

>   会存在，线程抢占这2个操作的时候，不会同时进行。

:::



:::tip 分析

1.   第一种情况：

     >   线程1：我在窗口1买到了第10张票，还没等到`--`操作，被线程2抢走了资源
     >
     >   线程2：我在窗口2买到了第10张票，因为线程1还没执行`--`操作，所以还是10张。线程2还没等到`--`操作，也被线程3抢走了资源
     >
     >   线程3：我在窗口3买到了第10张票，这个时候执行了`--`操作，此时票剩下9张
     >
     >   线程1：现在又抢到了资源，执行`--`，从9张剩下了8张
     >
     >   线程2：现在也抢到了资源，执行`--`，从8张剩下了7张

2.   第二种情况：

     现在就剩下1张票的情况

     >   线程1：我在窗口1买到了第1张票，还没等到`--`操作，被线程2抢走了资源
     >
     >   线程2：我在窗口2买到了第x张票，还没打印，就被线程3抢走了资源
     >
     >   线程3：我在窗口3买到了第x张票，还没打印，就被线程1抢走了资源
     >
     >   线程1：抢过来就继续执行`--`操作，现在票数为0
     >
     >   线程2：也会抢回资源执行`--`操作，现在票数就会变成`-1`，这是不被允许的情况
     >
     >   线程3：也抢回了资源执行`--`操作，现在票数就会变成`-2`，这也是不被允许出现的情况

:::

上面的代码出现问题，出现了重票、错票：即线程安全引起的问题

原因：多个线程，在争抢资源的过程中，导致共享的资源出现问题，一个线程还没执行完，另一个线程就参与进来了，开始争抢。



### 解决

案例：现在就一个厕所，很多人都想上厕所，第一个人进去的就会把门关上，加一把锁，别的人都进不去，就进行等待。可以保证一次厕所只能有一个人。

所以我们也可以在程序中在进行抢占资源的地方进行加锁，或者说加`同步监视器`



#### 方法1：同步代码块

```java
public class BuyTicketThread implements Runnable {

    int ticketNum = 10;

    /**
     * @see Thread#run()
     */
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            // 加锁
            synchronized (this) {
                if (ticketNum > 0) {
                    System.out.println("我在" + Thread.currentThread().getName() + "买到了第" + ticketNum-- + "张车票");
                }
            }
        }
    }
}

```

:::tip 疑问点

为什么锁加在了`for`里面的判断上，而不加在`for`上面？

>   如果加在了上面，这就表示这100个人，这就相当于，你给这100个人都加上了锁，100个人到了一个窗口1进行买票，这100个人都得等到买完了，其他的窗口才能继续；
>
>   所以把锁加在了抢票的代码上即可，无论有多少人在抢，你只要在对应的窗口等着就行。

**我们只需要在具有安全隐患的代码锁住即可，如果锁多了，就会效率低**



`synchronized (this)` -> `this`就是这个锁

:::