---
title: '日志'
date: 2021-11-14 11:01:15
# 永久链接
permalink: '/go/golog'
sidebar: 'auto'
isShowComment: true
categories:
 - go
tags:
 - log
author: 毛大
---



## 日志级别

[https://github.com/golang/glog](https://github.com/golang/glog)，是`google`提供的一个不维护的日志库，`glog`有其他语言的一些版本，它包含以下日志级别：

-   Info
-   Warning
-   Error
-   Fatal(会中断程序执行)

还有类似的`log4go，logo,zap`等其他第三方日志库，他们还提供了设置日志级别的可见性，一般提供日志级别：

-   Trace
-   Debug
-   Info
-   Warning
-   Error
-   Critical



### Warning

基本没人看警告，因为从定义上讲，没有什么出错。也许将来会有问题，但这听起来像是别人的问题。我们尽可能的消除警告级别，它要么是一条信息性消息，要么是一个错误。参考`Go`语言设计哲学，所有警告都是错误，其他语言的`warning`都可以忽略，除非IDE或者在`CICD`流程中强制他们为`error`，然后逼着程序员尽可能的去消除 。同样的，如果想要最终消除`warning`可以记录为`error`，让代码作者重视起来。

常见的就是`SpringBoot`运行起来，下面那一大片警告，一般确实没人会去关注。



### Fatal

记录消息后，会直接调用`os.Exit(1)`，这意味着：

-   在其他`gorouting defer`语句不会被执行
-   各种`buffers`不会被`flush`包括日志的
-   临时文件或者目录不会被移除

:::danger

不要使用`fatal`记录日志，而是向调用者返回错误。如果错误一直持续到`main.main`，`main.main`那就是在退出之前做处理任何清理操作的正确位置。

:::



### Error

也有很多在错误发生的地方要立马记录日志，尤其要使用`error`级别记录。

-   处理`error`
-   把`error`抛给调用者，在顶部打印日志

如果选择通过日志记录来处理错误，那么根据定义，它不再是一个错误，因为你已经处理了它。记录错误的行为会处理错误，因此不再适合将其记录为错误。

```go
err := somethingHard()
if err != nil {
    log.Error("oops, something was too hard", err)
    return err
}
```

```go
if err := planA(); err != nil {
    log.Infof("could't open the foo file, continuing to use planB")
    planB()
}
```

**这里产生了降级行为，本质属于有损服务 ，更倾向于在这里使用warning，应该要重视为什么planA经常失败**



### Debug

-   开发人员在开发或调试软件时关心的事情
-   用户在使用软件时关心的事情

它们分别是调试和信息级别

`log.Info`只需将该行写入日志输出，不应该有关闭它的选项，因为用户只应该被告知对他们有用的事情。

`log.Debug`是完全不同的事情，它由开发人员或支持工程师控制。在开发过程中，调试语句应该是丰富的，而不必求助于`trace`或`debug2`级别 。日志包应该支持细粒度控制，以启用或禁用调试，并且只在包或更精细的范围内启用或禁用调试语句。



B站是如何设计和思考的：[https://github.com/go-kratos/kratos/tree/v2.0.x/log](https://github.com/go-kratos/kratos/tree/v2.0.x/log)





## 日志选型

一个完整的集中式日志系统，需要包含以下几个主要特征：

-   收集：能够采集多种来源的日志数据
-   传输：能够稳定地把日志数据传输到中央系统
-   存储：如何存储日志数据
-   分析：可以支持UI分析
-   警告：能够提供错误报告，监控机制

>   开源界鼎鼎大名`ELK stack`，分别表示：`ElasticSearch,Logstash, Kibana`，他们都是开源软件。新增了一个`FileBeat`，它是一个轻量级的日志收集处理工具(`Agent`)，`FileBeat`占用资源少，适合于在各个服务器上搜集日志后传输给`Logstash`，官方也推荐此工具。





## 设计目标

-   接入方式收敛
-   日志格式规范
-   日志解析对日志系统透明
-   系统高吞吐、低延迟
-   系统高可用、容量可扩展、高可运维性



### 格式规范

JSON作为日志的输出格式：

-   time：日志产生时间，`ISO8601`格式
-   level：日志等级，ERROR, WARN, INFO,DEBUG
-   app_id：应用id，用于标识日志来源
-   instance_id：实例id，用于区分同一应用不同实例，即`hostname`

**可以使用`otel`规范**

