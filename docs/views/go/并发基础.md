---
title: 'Go并发基础'
date: 2021-09-24 20:54:15
# 永久链接
permalink: '/go/goroutine'
sidebar: 'auto'
isShowComment: true
categories:
 - go
tags:
 - goroutine
 - channel
---



:::tip

并发是编程里比较重要的概念。Go语言在语言层面上天生支持并发，这也是 Go 语言流行的重要原因

:::



## 进程和线程

:::tip

进程是计算机中资源分配的最小单元(相当于一个车间),一个进程中可以有多个线程(车间里的员工),同一个进程中的线程共享进程中的资源。（车间里的员工可以使用该车间的共享资源）。

:::

::: danger
**注意：进程与进程之间是相互隔离的，每个进程中都维护自己独立的数据，不进行共享；如果想让他们之间进行共享，需要借助一些特殊的办法去实现**
:::



## 并发与并行

并发：同一时间段内执行多个任务

并行：同一时间段内多个CPU执行同一件任务

Go语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，也叫`协程`，是程序员自己弄出来的。`goroutine`是由Go语言的运行时`runtime`调度完成的，而线程是由操作系统内核调度完成的。

Go语言提供`channel`在多个`goroutine`间进行通信。`goroutine`和`channel`是Go语言秉承的CSP(Communicating Sequential Process)并发模式的重要实现基础。



### 协程

协程的优势：

1.   协程的内存消耗更小
     -   一个线程可以包含多个协程
     -   线程大约2MB的内存申请量
     -   协程大概2KB的内存申请量，最大可以扩大的到1G
2.   上下文切换更快
     -   协程少一道手续
     -   线程申请内存，需要走过内核
     -   协程申请内存，不需要走过内核



>   Goroutine实质上是一种协程

1.   去掉了冗余的协程生命周期管理
     1.   协程创建
     2.   协程完成
     3.   协程重用
2.   降低额外的延迟和开销
     1.   由于协程间频繁交互导致的
3.   降低加锁、解锁的效率
     1.   降低一部分额外的开销



### 通信

并发编程的难度在于协调，而协调需要通过交流，并发单元间的通信是最大的问题。

在工程上有两种最常见的并发通信模型：共享数据和消息

Go语言是在`csp`模型基础上进行实现的。

:::danger

一个`channel`只能传递一种类型的值；可以认为是一种类型安全的管道。类型安全就是一种线程安全

:::



## 使用goroutine

Go语言中使用`goroutine`非常简单，只需要在调度函数的时候在前面加上`go`关键字，就可以为一个函数创建一个`goroutine`

一个`goroutine`必定对应一个函数，可以创建多个`goroutine`去执行相同的函数。



### 启动单个goroutine

```go
package main

import "fmt"

func hello() {
	fmt.Println("hello goroutine")
}

func main() { // 启动的时候会开启一个 main 的goroutine去执行main函数
	go hello() // 开启了一个独立的goroutine去执行hello函数

	fmt.Println("main goroutine done!")
}

```

这一次的执行结果只打印了`main goroutine done`，`hello()`函数还没来得及执行就结束了。所以需要在结尾加上延迟几秒进行等待。

```go
package main

import (
	"fmt"
	"time"
)

func hello() {
	fmt.Println("hello goroutine")
}

func main() {
	go hello()

	fmt.Println("main goroutine done!")
	time.Sleep(time.Second) // 让主的goroutine 等待1秒钟
}


>>>输出
hello goroutine
main goroutine done!

```

`main`函数执行完了，就代表整个就结束了，所以没加上延迟阻塞，别的`goroutine`根本来不及去执行，程序占用的资源也就关闭了。

:::tip

但是这里并不建议在生产环境中使用`time.Sleep`，可以使用`sync`包的`WaigGroup`来实现

:::

```go
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func hello() {
	fmt.Println("hello goroutine")
	wg.Done() // 告诉 main 函数 执行完了  通知 wg把计数器-1
}

func main() {

	wg.Add(1) // 技数牌+1
	go hello()

	fmt.Println("main goroutine done!")
	//time.Sleep(time.Second)

	// 等待别的goroutine干完活才结束
	wg.Wait() // 阻塞，等到计数器归零，就会结束
}

```

上述是开启了一个`goroutine`，如果开启多个呢

### 启动多个goroutine

```go
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func hello(i int) {
	fmt.Println("hello goroutine", i)
	wg.Done() // 告诉 main 函数 执行完了  通知 wg把计数器-1
}

func main() {

	//wg.Add(1) // 技数牌+1

	wg.Add(10000) // 一次全加满
	for i := 0; i < 10000; i++ {
		//wg.Add(1) // 或者每有一个goroutine加一个
		go hello(i)
	}

	fmt.Println("main goroutine done!")
	//time.Sleep(time.Second)

	// 等待别的goroutine干完活才结束
	wg.Wait() // 阻塞，等到计数器归零，就会结束
}

```

使用匿名函数闭包出现的问题以及解决办法

```go
package main

import (
	"fmt"
	"sync"
)

var wg2 sync.WaitGroup

func main() {
	wg2.Add(10000) // 一次全加满
	for i := 0; i < 10000; i++ {
		// wg2.Add(1) // 或者每有一个goroutine加一个
		go func(i int) {
			// 换成匿名函数(闭包) 包含了一个外部函数的一个变量的引用
			fmt.Println("hello", i)
			wg2.Done() // 都执行完了，通知结束
		}(i) // 此时的i是每次for循环的i传进来的 副本
	}

	fmt.Println("main goroutine done!")

	// 等待别的goroutine干完活才结束
	wg2.Wait() // 阻塞，等到计数器归零，就会结束
}

```



### goroutine的调度

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

var wg3 sync.WaitGroup

func a() {
	for i := 0; i < 10; i++ {
		fmt.Println("a", i)
	}
	wg3.Done()
}

func b() {
	for i := 0; i < 10; i++ {
		fmt.Println("b", i)
	}
	wg3.Done()
}

func c() {
	for i := 0; i < 10; i++ {
		fmt.Println("c", i)
	}
	wg3.Done()
}

func main() {
	runtime.GOMAXPROCS(1) // 只占用一个CPU核心

	wg3.Add(2)
	go a()
	go b()

	wg3.Wait()
	//time.Sleep(time.Second)
}

```

此时只会专门完成其中一个，再去执行另外一个。



Go语言中的操作系统线程和goroutine的关系：

1.   一个操作系统线程对应用户态多个goroutine
2.   go程序可以同时使用多个操作系统线程
3.   goroutine和OS线程是多对多关系，即`m:n`



## channel的使用



