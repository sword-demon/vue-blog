---
title: 'Go并发基础'
date: 2021-09-24 20:54:15
# 永久链接
permalink: '/go/goroutine'
sidebar: 'auto'
isShowComment: true
categories:
 - go
tags:
 - goroutine
 - channel
---



:::tip

并发是编程里比较重要的概念。Go语言在语言层面上天生支持并发，这也是 Go 语言流行的重要原因

:::



## 进程和线程

:::tip

进程是计算机中资源分配的最小单元(相当于一个车间),一个进程中可以有多个线程(车间里的员工),同一个进程中的线程共享进程中的资源。（车间里的员工可以使用该车间的共享资源）。

:::

::: danger
**注意：进程与进程之间是相互隔离的，每个进程中都维护自己独立的数据，不进行共享；如果想让他们之间进行共享，需要借助一些特殊的办法去实现**
:::



<!-- more -->

## 并发与并行

并发：同一时间段内执行多个任务

并行：同一时间段内多个CPU执行同一件任务

Go语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，也叫`协程`，是程序员自己弄出来的。`goroutine`是由Go语言的运行时`runtime`调度完成的，而线程是由操作系统内核调度完成的。

Go语言提供`channel`在多个`goroutine`间进行通信。`goroutine`和`channel`是Go语言秉承的CSP(Communicating Sequential Process)并发模式的重要实现基础。



### 协程

协程的优势：

1.   协程的内存消耗更小
     -   一个线程可以包含多个协程
     -   线程大约2MB的内存申请量
     -   协程大概2KB的内存申请量，最大可以扩大的到1G
2.   上下文切换更快
     -   协程少一道手续
     -   线程申请内存，需要走过内核
     -   协程申请内存，不需要走过内核



>   Goroutine实质上是一种协程

1.   去掉了冗余的协程生命周期管理
     1.   协程创建
     2.   协程完成
     3.   协程重用
2.   降低额外的延迟和开销
     1.   由于协程间频繁交互导致的
3.   降低加锁、解锁的效率
     1.   降低一部分额外的开销



### 通信

并发编程的难度在于协调，而协调需要通过交流，并发单元间的通信是最大的问题。

在工程上有两种最常见的并发通信模型：共享数据和消息

Go语言是在`csp`模型基础上进行实现的。

:::danger

一个`channel`只能传递一种类型的值；可以认为是一种类型安全的管道。类型安全就是一种线程安全

:::



## 使用goroutine

Go语言中使用`goroutine`非常简单，只需要在调度函数的时候在前面加上`go`关键字，就可以为一个函数创建一个`goroutine`

一个`goroutine`必定对应一个函数，可以创建多个`goroutine`去执行相同的函数。



### 启动单个goroutine

```go
package main

import "fmt"

func hello() {
	fmt.Println("hello goroutine")
}

func main() { // 启动的时候会开启一个 main 的goroutine去执行main函数
	go hello() // 开启了一个独立的goroutine去执行hello函数

	fmt.Println("main goroutine done!")
}

```

这一次的执行结果只打印了`main goroutine done`，`hello()`函数还没来得及执行就结束了。所以需要在结尾加上延迟几秒进行等待。

```go
package main

import (
	"fmt"
	"time"
)

func hello() {
	fmt.Println("hello goroutine")
}

func main() {
	go hello()

	fmt.Println("main goroutine done!")
	time.Sleep(time.Second) // 让主的goroutine 等待1秒钟
}


>>>输出
hello goroutine
main goroutine done!

```

`main`函数执行完了，就代表整个就结束了，所以没加上延迟阻塞，别的`goroutine`根本来不及去执行，程序占用的资源也就关闭了。

:::tip

但是这里并不建议在生产环境中使用`time.Sleep`，可以使用`sync`包的`WaigGroup`来实现

:::

```go
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func hello() {
	fmt.Println("hello goroutine")
	wg.Done() // 告诉 main 函数 执行完了  通知 wg把计数器-1
}

func main() {

	wg.Add(1) // 技数牌+1
	go hello()

	fmt.Println("main goroutine done!")
	//time.Sleep(time.Second)

	// 等待别的goroutine干完活才结束
	wg.Wait() // 阻塞，等到计数器归零，就会结束
}

```

上述是开启了一个`goroutine`，如果开启多个呢

### 启动多个goroutine

```go
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func hello(i int) {
	fmt.Println("hello goroutine", i)
	wg.Done() // 告诉 main 函数 执行完了  通知 wg把计数器-1
}

func main() {

	//wg.Add(1) // 技数牌+1

	wg.Add(10000) // 一次全加满
	for i := 0; i < 10000; i++ {
		//wg.Add(1) // 或者每有一个goroutine加一个
		go hello(i)
	}

	fmt.Println("main goroutine done!")
	//time.Sleep(time.Second)

	// 等待别的goroutine干完活才结束
	wg.Wait() // 阻塞，等到计数器归零，就会结束
}

```

使用匿名函数闭包出现的问题以及解决办法

```go
package main

import (
	"fmt"
	"sync"
)

var wg2 sync.WaitGroup

func main() {
	wg2.Add(10000) // 一次全加满
	for i := 0; i < 10000; i++ {
		// wg2.Add(1) // 或者每有一个goroutine加一个
		go func(i int) {
			// 换成匿名函数(闭包) 包含了一个外部函数的一个变量的引用
			fmt.Println("hello", i)
			wg2.Done() // 都执行完了，通知结束
		}(i) // 此时的i是每次for循环的i传进来的 副本
	}

	fmt.Println("main goroutine done!")

	// 等待别的goroutine干完活才结束
	wg2.Wait() // 阻塞，等到计数器归零，就会结束
}

```



### goroutine的调度

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

var wg3 sync.WaitGroup

func a() {
	for i := 0; i < 10; i++ {
		fmt.Println("a", i)
	}
	wg3.Done()
}

func b() {
	for i := 0; i < 10; i++ {
		fmt.Println("b", i)
	}
	wg3.Done()
}

func c() {
	for i := 0; i < 10; i++ {
		fmt.Println("c", i)
	}
	wg3.Done()
}

func main() {
	runtime.GOMAXPROCS(1) // 只占用一个CPU核心

	wg3.Add(2)
	go a()
	go b()

	wg3.Wait()
	//time.Sleep(time.Second)
}

```

此时只会专门完成其中一个，再去执行另外一个。



Go语言中的操作系统线程和goroutine的关系：

1.   一个操作系统线程对应用户态多个goroutine
2.   go程序可以同时使用多个操作系统线程
3.   goroutine和OS线程是多对多关系，即`m:n`



## channel的使用

Go语言的并发模型`CSP`提倡**通过通信共享内存**而不是通**过共享内存而实现通信**。

如果goroutine是Go程序并发的执行体，`channel`就是它们之间的连接。`channel`是可以让一个`goroutine`发送特定的值到另一个`goroutine`的通信机制。

Go语言的通道 `channel`是一种 特殊的类型，总是遵循先入先出的规则，保证收发数据的顺序。每个通道都是一个具体类型的管道。



### channel类型

`channel`是一种类型，而且是一种引用类型，**使用时需要初始化**。声明格式：

```go
var 变量 chan 元素类型
```

```go
var ch1 chan int // 声明一个传递int类型的通道
var ch2 chan bool // 声明一个传递布尔类型的通道
var ch3 chan []int // 声明一个传递int切片的通道
```



### 创建channel

它是引用类型，该类型的空值是`nil`

```go
var ch chan int
fmt.Println(ch) // <nil>
```

:::danger

声明`channel`后需要使用`make`进行初始化后才能使用

:::

`channel`的缓冲大小是可选的。

```go
ch3 := make(chan int)
ch4 := make(chan bool)
ch5 := make(chan []int)
```



### channel操作

-   发送 send
-   接收 receive
-   关闭 close

:::tip

发送和接收都使用`<-`符号

1.   `channel`在`<-`左边就是发送
2.   `channel`在`<-` 右边就是接收

:::

先定义一个channel

```go
ch := make(chan int)
```



#### 发送

将一个值发送到`channel`中

```go
ch <- 10 // 把10 发送到 ch 中
```



#### 接收

从一个`channel`中接收值

```go
x := <- ch // 从ch中接收值并赋值给变量x
<-ch // 从ch中接收值 忽略结果
```



#### 关闭

通过调用内置的`close`函数来进行关闭`channel`

```go
close(ch)
```

:::danger

关于关闭`channel`需要注意：只有在通知接收方`goroutine`所有的数据都发送完毕的时候才需要关闭。`channel`是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作后关闭文件时必须要做的，但是关闭`channel`不是必须的。

:::

**关闭后的`channel`有以下特点**

1.   对一个关闭的`channel`在发送数据就会导致`panic`
2.   对一个关闭的`channel`进行接收会一直获取值直到`channel`为空
3.   对一个关闭的`channel`的并且没有值的`channel`执行接收操作会得到对应类型的零值
4.   关闭一个已经关闭的`channel`会导致`panic`



### 无缓冲的channel

无缓冲的`channel`又称之为阻塞的通道，也叫同步`channel`

```go
func main() {
  ch := make(chan int)
  ch <- 10 // 往ch发送值，没有缓冲区，它不能暂存值，一直阻塞，除非有另外一个goroutine从里面进行取值
  fmt.Println("发送成功")
}
```

:::danger

上述代码能够通过编译，但是执行会报错

`fatal error: all goroutines are asleep - deadlock!`

死锁了！

**也就是说，发送数据必须有一个接受者，否则就是阻塞**

:::



一种方法是启用一个`goroutine`去接收值，例如：

```go
func recv(c chan int) {
	ret := <-c
	fmt.Println("接收成功", ret)
}
func main() {
	ch := make(chan int)
	go recv(ch) // 启用goroutine从通道接收值
	ch <- 10
	fmt.Println("发送成功")
}
```

无缓冲通道上的发送操作会阻塞，直到另一个`goroutine`在该通道上执行接收操作，这时值才能发送成功，两个`goroutine`将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个`goroutine`在该通道上发送一个值。

使用无缓冲通道进行通信将导致发送和接收的`goroutine`同步化。因此，无缓冲通道也被称为`同步通道`。

### 带缓冲区的channel

又称之为异步`channel`

```go
func main() {
	ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道
	ch <- 10
	fmt.Println("发送成功")
}
```

>   通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。



```go
package main

import "fmt"

func sender(ch chan int) {
	for i := 0; i < 100; i++ {
		ch <- i // 发送i
	}
	// 发送玩就关闭 ch
	close(ch)
}

func receiver(ch1, ch2 chan int) {
	// 从channel中取值的方式1
	for {
		tmp, ok := <-ch1
		// 100个值取完了，ok => false 就代表取完了
		if !ok {
			break
		}
		ch2 <- tmp * tmp
	}
	close(ch2)
}

func main() {
	ch1 := make(chan int, 100)
	ch2 := make(chan int, 200)

	go sender(ch1)
	go receiver(ch1, ch2)

	// 从channel中取值的方式2
	for ret := range ch2 {
		// 内部会判断取值遇到了false就会退出
		fmt.Println(ret)
	}
}

```

```go
package main

import "fmt"

// 只能往里面发
func sender(ch chan<- int) {
	for i := 0; i < 100; i++ {
		ch <- i // 发送i
	}
	// 发送玩就关闭 ch
	close(ch)
}

// 从ch1取值，把结果发送个ch2
// ch1 只能取
// ch2 只能发
func receiver(ch1 <-chan int, ch2 chan<- int) {
	// 从channel中取值的方式1
	for {
		tmp, ok := <-ch1
		// 100个值取完了，ok => false 就代表取完了
		if !ok {
			break
		}
		ch2 <- tmp * tmp
	}
	close(ch2)
}

func main() {
	ch1 := make(chan int, 100)
	ch2 := make(chan int, 200)

	go sender(ch1)
	go receiver(ch1, ch2)

	// 从channel中取值的方式2
	for ret := range ch2 {
		// 内部会判断取值遇到了false就会退出
		fmt.Println(ret)
	}
}

```

:::tip

`chan<- int`是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作

`<-chan int`是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。

:::