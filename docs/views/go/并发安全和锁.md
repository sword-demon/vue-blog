---
title: '并发安全和锁'
date: 2021-09-27 21:33:15
# 永久链接
permalink: '/go/safe_lock'
sidebar: 'auto'
isShowComment: true
categories:
 - go
tags:
 - goroutine
 - channel
 - lock
---



## 并发安全和锁

案例

```go
package main

import (
	"fmt"
	"sync"
)

// 多个goroutine并发操作全局变量x

var (
	x  int64
	wg sync.WaitGroup
)

func add() {
	for i := 0; i < 5000; i++ {
		// 1. 拿到全局变量x
		// 2. 给这个值+1
		// 3. 加1后在赋值给全局变量x
		x++ // 对全局变量进行每次+1
	}
	wg.Done()
}

func main() {
	wg.Add(2)
	go add()
	go add()
	wg.Wait()
	fmt.Println(x) // 7180 5285 各种值
}

```



<!-- more -->

## 互斥锁

使用互斥锁来解决上述的问题。互斥锁是一种常用来控制共享资源访问的方法，它能够保证同时只有一个`goroutine`可以访问共享资源。Go语言中使用`sync`包里的`Mutex`类型来实现互斥锁。

```go
package main

import (
	"fmt"
	"sync"
)

// 多个goroutine并发操作全局变量x

var (
	x  int64
	wg sync.WaitGroup
	lock sync.Mutex
)

func add() {
	for i := 0; i < 5000; i++ {
		// 1. 拿到全局变量x
		// 2. 给这个值+1
		// 3. 加1后在赋值给全局变量x
		lock.Lock() // 加锁
		x++ // 对全局变量进行每次+1
		lock.Unlock() // 释放锁
	}
	wg.Done()
}

func main() {
	wg.Add(2)
	go add()
	go add()
	wg.Wait()
	fmt.Println(x) // 10000 这个时候不管执行多少次都是10000
}

```



### 使用一个容量为1的通道来保证同一时间最多有一个goroutine能访问共享变量

```go
package main

var (
	sema    = make(chan struct{}, 1) // 用来保护  balance的二进制信号量
	balance int
)

func Deposit(amount int) {
	sema <- struct{}{} // 获取令牌
	balance = balance + amount
	<-sema // 释放令牌
}

func Balance() int {
	sema <- struct{}{} // 获取令牌
	b := balance
	<-sema // 释放令牌
	return b
}

```

>   使用`sync.Mutext`

```go
package main

import "sync"

var (
	//sema    = make(chan struct{}, 1) // 用来保护  balance的二进制信号量
	mu sync.Mutex
	balance int
)

func Deposit(amount int) {
	//sema <- struct{}{} // 获取令牌
	mu.Lock()
	balance = balance + amount
	//<-sema // 释放令牌
	mu.Unlock()
}

func Balance() int {
	//sema <- struct{}{} // 获取令牌
	mu.Lock()
	b := balance
	//<-sema // 释放令牌
	mu.Unlock()
	return b
}

```



## 读写互斥锁

很多实际场景读的比写的多，读不涉及一个资源的更改和变幻，是没有必要加锁的，这样使用读写互斥锁比较适合。读写锁在Go语言里使用`sync`包的`RWMutex`类型。

读写锁：

-   当一个`goroutine`获得读锁只有，其他的`goroutine`如果是获取读锁会继续获取读锁，如果是写锁就会等待。
-   当一个`goroutine`获取写锁时，其他的`goroutine`无论是读还是写锁都会等待。

案例：

```go
// 使用互斥锁的时间

package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	x    int64
	wg   sync.WaitGroup
	lock sync.Mutex
)

func read() {
	lock.Lock()
	time.Sleep(time.Millisecond)
	lock.Unlock()
	wg.Done()
}

func write() {
	lock.Lock()
	x++
	time.Sleep(time.Millisecond * 10)
	lock.Unlock()
	wg.Done()
}

func main() {
	start := time.Now()
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go read()
	}

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go write()
	}

	wg.Wait()
	fmt.Println(time.Now().Sub(start))
}

>>>输出
1.387438292s

```

```go
// 使用读写锁

package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	x    int64
	wg   sync.WaitGroup
	rwLock sync.RWMutex
)

func read() {
	rwLock.RLock() // 读锁
	time.Sleep(time.Millisecond)
	rwLock.RUnlock() // 是否读锁
	wg.Done()
}

func write() {
	rwLock.Lock()
	x++
	time.Sleep(time.Millisecond * 10)
	rwLock.Unlock()
	wg.Done()
}

func main() {
	start := time.Now()
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go read()
	}

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go write()
	}

	wg.Wait()
	fmt.Println(time.Now().Sub(start))
}

>>>输出
122.424125ms

```

:::danger

**读写锁是非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来**

:::



## sync.Once

在某些场景下，某些操作只需要执行一次，例如只加载一次配置文件，只关闭一次通道等。

Go语言中使用`sync`包中的`Once`类型

它只有一个`Do`方法

```go
func (o *Once) Do (f func()) {}
```



### 加载配置文件案例

延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的时间。因为预先初始化一个变量(比如使用`init`函数中完成的初始化)会增加程序的启动耗时，而且这个变量可能后面都没用上，那么这个初始化就不是必要的。

```go
var icons map[string]image.Image

func loadIcons() {
	icons = map[string]image.Image{
		"left":  loadIcon("left.png"),
		"up":    loadIcon("up.png"),
		"right": loadIcon("right.png"),
		"down":  loadIcon("down.png"),
	}
}

func Icon(name string) image.Image {
	if icons == nil {
		loadIcons()
	}
	return icons[name]
}
```

多个`goroutine`并发同时调用Icon函数时并不是并发安全的。

使用`sync.Once`改造

```go
var icons map[string]image.Image

var loadIconsOnce sync.Once

func loadIcons() {
	icons = map[string]image.Image{
		"left":  loadIcon("left.png"),
		"up":    loadIcon("up.png"),
		"right": loadIcon("right.png"),
		"down":  loadIcon("down.png"),
	}
}

func Icon(name string) image.Image {
  loadIconsOnce Do(loadIcons)
	return icons[name]
}
```

